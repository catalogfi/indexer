package store_test

import (
	"time"

	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	"github.com/catalogfi/indexer/model"
	"github.com/catalogfi/indexer/store"
	"github.com/onsi/ginkgo"
	"github.com/onsi/gomega"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

var _ = ginkgo.Describe("Storage", func() {
	var (
		db      *gorm.DB
		params  *chaincfg.Params
		storage store.Storage
	)

	ginkgo.BeforeEach(func() {
		// Create an in-memory SQLite database for testing
		var err error
		db, err = gorm.Open(sqlite.Open("file::memory:"), &gorm.Config{})
		gomega.Expect(err).NotTo(gomega.HaveOccurred())
		gomega.Expect(db.AutoMigrate(&model.Block{}, &model.Transaction{}, &model.OutPoint{})).To(gomega.Succeed())

		params = &chaincfg.MainNetParams

		// Create a storage instance
		storage = store.NewStorage(params, db)
	})

	ginkgo.AfterEach(func() {
		// Close the database connection
		sqlDB, err := db.DB()
		gomega.Expect(err).NotTo(gomega.HaveOccurred())
		err = sqlDB.Close()
		gomega.Expect(err).NotTo(gomega.HaveOccurred())
	})

	ginkgo.Describe("PutBlock", func() {
		ginkgo.It("should store the block in the database", func() {
			// Create a sample block
			block := &wire.MsgBlock{
				Header: wire.BlockHeader{
					Version:    536870912,
					PrevBlock:  chainhash.Hash{6, 34, 110, 70, 17, 26, 11, 89, 202, 175, 18, 96, 67, 235, 91, 191, 40, 195, 79, 58, 94, 51, 42, 31, 199, 178, 183, 60, 241, 136, 145, 15},
					MerkleRoot: chainhash.Hash{210, 231, 106, 251, 161, 35, 222, 124, 214, 164, 246, 131, 37, 106, 18, 68, 127, 175, 21, 139, 194, 110, 17, 254, 83, 169, 125, 86, 116, 199, 142, 202},
					Timestamp:  time.Now(),
					Bits:       545259519,
					Nonce:      0,
				},
				Transactions: []*wire.MsgTx{
					{
						// Add transaction details if needed
					},
				},
			}

			// Store the block in the database
			err := storage.PutBlock(block)
			gomega.Expect(err).NotTo(gomega.HaveOccurred())

			// Retrieve the stored block from the database
			// storedBlock, err := storage.GetBlock(block.Header.Hash[:])
			// gomega.Expect(err).NotTo(gomega.HaveOccurred())
			// gomega.Expect(storedBlock).NotTo(gomega.BeNil())
			// gomega.Expect(storedBlock.Header.Hash).To(gomega.Equal(block.Header.Hash))
		})
	})
})
